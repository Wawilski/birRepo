NetworkX

Invariant de graphe
_________________________________________

Moyenne et Variance des degrés de sommets de graphe

1- calculer Moyenne et Variance des noeuds d'un graphe donné (done)
2- faire des tests 
  créer des graphes randoms et si isomorphes regarder si même moyenne et même variance

Sachant que c'est bien un invariant:
  invariant = quantité qui est la meme pour tout graphe isomorphe  

  isomorphe => on peut associer ts les sommets d'un graphe G vers un graphe H et garde les arêtes


  sachant ça cela signifie que pour un sommet a de G, le sommet associé f(a) dans H possèdent le même nombre d'arrete et donc le meme degré
  et ce pour toutes les arretes. Si toutes les aretes on le meme degré entre 2 graphes alors la moyenne ne change pas car le meme nombre de noeud et les memes degrés
  comme la moyenne change pas et le degré change pas on est good


  Moyenne plus fort encore, si 2 graphes ont le meme nombre d'arete alors la moyenne des degrés est égale
  Logique en soit car une arete = 2 degrés distribués parmis les nodes et ce peut importe les nodes en questions
  et la moyenne additionne tous les degrés des noeuds donc sil y a une aretes qui change d'un noeud a un autre on a quand meme la meme moyenne des degrés comme lentrant dans lancien nodes
  juste se déplace

  Variance par contre que si isomorphes parce que les degrés respectifs des noeuds comptent


PRENDRE GRAPHES DU MAIL AVEC SIGNATURES CANONIQUES
CALCULER VALEUR DE VARIANCE POUR CHACUN
PRINT SINGATURE CANONIQUE ET VARIANCE

Bcp de valeurs: 12293434 values
Variance !=> iso
iso => Variance
_________________________________________

Circonference d'un graphe girth = plus court cycle
Deja implémenté mais implemente le

PLUS COURT CYCLE:

parcours en partant de chaque node on prend le plus court

BFS et dès qu'on tombe sur le node on prend la value

=================================================
Jour 2: treewidth
================================================
Plus petite decomposition


---pas bonne méthode heuristique---
Prend le gros TAS avec tous les nodes
au fur et a mesure on prend celui qui à le plus petit degré et on regarde a qui il est connecté dans le grand ensemble si cest possible on le retire et on ajoute un
node avec tous ses voisins
On continue dans que cest possible puis on passe sur un des noeuds créés et à la chaine 


--Naif--
tu prends tous les sous ensembles et tu composes pour voir si ca marche
Remarque de non tree

SI 2 eleement d'un noeud appartiennent a 2 noeud differents et 1 elemennt commun entre les 2 => merge
Ex:
  AB BC AC => ABC

Si double paire A B B A, A C C A Merge à 4

  BC CE BD DE => BCDE

=> premier tri 
Pour toutes les aretes checker si triangles dans ce cas il y a d'office un noeud qui contient les 3
Probablement plus long que de try



Naive method mais pas trop

Tous les sous ensembles possibles
commence par Sous ensemlbes plus petits (aretes)

On part d'une arete et on la link avec une possible 
si pas possible de link avec arete voisine merge les 2

si en ajoutant voisin on tombe sur un cycle
on prend ceux qui ont un commun on les mergent et le chiant on le met au milieu en ajoutant les commun des 2 merges
Marche pas

Naive method ++
On prend les ensembles d'arretes avec 2 item par node
puis 3 puis 4 ... 
- dès qu'on trouve un cycle on switch de possibilité et au bout d'un moment on atteindra bien un truc
- dès qu'on trouve une solution on est bon
sachant que peut pas dépasser n-1 item par noeud et peut pas etre en dessous de n-1 noeuds(nombre d'arrete)
        


=================================================
Jour 3: TreeWidth: le retour
=================================================


-- Ca ne lest pas --
Analyse de cliques voir si cest plus simple ou pas

TreeWidth = taille de la plus grande clique dans le chordal graph qui contient G avec le plus petit nombre de clique

Graph cordal: graphe avec pour chaque cycle de 4 ou plus à au moins une corde qui connecte 2 node du circuit


MEthod naive mais pas trop
Creation de tous les noeuds necessaire pour un certains K 
tentative de connection en ajoutant des noeuds, si marche pas switch et faire toutes les possibilités pour un k donné

Si 2 et cycle on switch instant

Pour petits seems fine pour 10 complex



OK final algo from Melo


Logique algo

Algorithme naif, on va faire toutes les possibilités mais de maniere intelligente

Soit:
-G un graph dont on veut connaitre la treewidth, 
ses nodes sont numérotées de 0 à n, n le nombre de node 

o_perm correspond a la liste des nodes de G, numérotés selon un certain ordre,
cette variable permettra de stocker les permutations des nodes

L'algo suit la logique suivante:
  
  Nous allons créer un nouveau graphe, C, copie de G, sauf que nous allons renommés les sommets selon o_perm
  Cela permettra par la suite d'explorer les aretes des noeuds dans un ordre different à chaque itération
  permettant d'explorer toutes les possibilités de treeDecomposition
  
  Après avoir créé ce graphe C, nous allons calculer le degré Maximum dans C, nMaxDeg
  Ce degré nous permettra de connaitre la width de l'arbre

  Pour ce faire nous allons explorer les noeuds de C dans l'ordre numérique
  Pour chaque noeud i nous allons stocker le degré courant dans nDeg et allons garder en mémoire
  first, le premier noeud avec qui i à une arete en commun
  Nous allons donc a partir de i explorer les noeuds dont le numéro est strictement supérieur à i
  et verifier sil y a une arete, si cest le cas nous incrémentons nDeg et verifions si j est le premier
  noeud avec qui il y a liaison, si cest le cas nous le stockons dans first sinon nous ajoutons une arete
  dans C reliant first et j


  Cela permetra de gérer les cycles problematiques dans le graphe s'il y en a, en ajoutant cette arrete
  on ajoute un au degré de j et de first et donc potentiellement la cardinalité des nodes via nDeg et nMaxDeg
=====
TODO
=====
repo Git 

Continuer ce tree stuff et améliorer efficacité tout ça tout ça

suite
Comparaison defficacité RUST

invariants en plus
  proximity: Minimum de la distance moyenne des sommets du graphe
  remoteness: Maximum de la distance moyenne des sommets du graphe
  calculer? tu pars d'un sommet tu fais le plus cours chemin vers tous les sommets et tu stock 
  en gros BFS et tu gardes les distances à chaque fois tu peux opti en gardant la distance vers les noeuds que t'as deja visit pour les prochains mais pas worth parce que tu devras
  quand meme calculer


================================
Jour 4
===============================

repo git done
Proximity & remoteness implementés reste que le g6 file mais apres

a faire:
tenter de clean tout ce que deja fait
files g6 full (ff)
tenter de voir implementation en rust probablement plus fast uk


Ameliorer TreeWidth
  - Trouver borne inferieure et si atteinte alors on stop ? Done et marche bien permet pour certains graphes particuliers de le faire en une itération (exemple dans main avec le grapges à 7 sommets avec que des triangles) ou alors les fully connected graph
  - Break si on a un degré superieur au minimum (logique) done et is ok ca reduit deja bien (si on considère que le 1er noeud a un degré superieur on gagne n**2 itération cest pas mal)
  - Ignorer des permutations? un monde ou c'est possible

lower bound sur small
Economie de 4 secondes 
lower bound sur middle (que ceux de taille 7)
avec lower: 32 sec
sans lower : 2min
divise le temps par 4 de ce que vu



Reste à faire:
Rust
Encore ptetre améliorer treewidth avec upperbound
file g6 remoteness & proximity


============================
Jour 5
============================


Implémentation des graphs, girth et tree_width en rust

######################################################
                  Semaine 2
######################################################

===========================
Jour 1
===========================

Fixing Proximity and Remoteness + faire files (done)

Rust: Implémentation Lower Bound TreeWidth, Proximity and Remoteness

Temps exe

          Tree_width
Rust          |   Python 
            Small 
        Moyenne temps
0.441927 ms   |   1.472783 ms
        Global temps
91.928201 ms  |   313.796831 ms

            Seven         
        Moyenne temps
8.761376 ms   |   30.830548 ms
        Global temps
9.135605 s    |   32.038462 s



Implémenter Prox et Remoteness


     Proximity/Remoteness
    (Probablement Probleme)
Rust          |   Python 
            Small 
        Moyenne temps
0.021859 ms   |   0.038064 ms
        Global temps
4.524906 ms  |    7.879252 ms

            Seven         
        Moyenne temps
0.034531 ms   |   0.056277 ms
        Global temps
36.050836 ms    |   58.753757 ms
     

            Girth
Rust          |   Python 
            Small 
        Moyenne temps
0.020546 ms   |   0.029426 ms
        Global temps
4.253045 ms  |    6.091343 ms

            Seven         
        Moyenne temps
0.031026 ms   |   0.044273 ms
        Global temps
32.391704 ms    |  46.221144 ms
            
          Variance
Rust          |   Python 
            Small 
        Moyenne temps
0.009553 ms   |   0.016899 ms
        Global temps
1.977510 ms  |    3.498293 ms

            Seven         
        Moyenne temps
0.010675 ms   |   0.021364 ms
        Global temps
11.145605 ms    |  22.304676 ms


=======================================
  Jour 2
======================================

Recap:
  Invariants en python et en rust
    Variance
    Girth (circonférence)
    Proximity
    Remoteness
    Tree Width
  Comparaison des temps d'exe des algos
    Rust toujours plus rapide meme si ptetre améliorable

#TODO
  CLEAN CODE ET AMELIORER STUFF
  SIGNER CONTRAT
  
Rust Cleaned au max du possible

AMELIORER TREE WIDTH


Ok upperbound

tw(G) < |S| + max(tw(G_i))


=> Retire vertices puis prends la tailles des sous graph de G - S - 1 pour leur tw
ca créra un upperbound qui sera impossible d'aller au dessus

=====================================
Jour 3
=====================================

ALGORITHMES A EXPLO

Arnborg et al. O(n^k+2) Pour dire si tree width de taille au plus k <= en vrai à l'ai sympa O(2^n) pour un k donné

Farni et al. && Villanger Use Separator et cliques (vu hier takapté) O(1.9^n) pour Farni et un peu moins pour VIllanger <= Peut etre sympa mais disent dur à implementer

Paper Found <= Linear Ordering Vertices tq specific measure of cost as small as possible O(2^n) jsp ce que ca signifie mais ca à l'air marrant



Propal intéressantes 

soit G = (V,E), k entier

1. tw(G) =k
<=>
2. G a triangulation H = (V,F) avec max taille de clique = k +1
<=>
3. Same que 2 mais H triangulation minimale


Tenter a implémenté 
Recursive Algo O(4^n) mieux que l'autre en O(n!)
  Calculer 2 choses:
    Q(L,v) = |{w from V - S - {v}| path between v and w dans G[S U {v,w}]}|
    Subsets de S, S' avec |S'| = |S|/2

Ok implémenté mais à debuguer

Demain 
  Debuguer parce que stack overflow
  Check reste des algos du papier
  Si le temps check Arnborg

=====================================
Jour 4
====================================
Recursif done 

          Tree_width
tree_width    |  tree_width_rec (non opti)
            Small 
        Moyenne temps
0.441927 ms   | 1.547482 ms
         Global temps
91.928201 ms  | 320.328936 ms


            Seven         
        Moyenne temps
8.761376 ms   | 8.652135 ms
        Global temps
9.135605 s    | 9.032829 s

2030029038
1²944472

meme si pas optimisé il s'améliore quand on monte en taille et rattrape le tree_width par defaut

######################################################
                  Semaine 3
######################################################

===========================
Jour 1
===========================

TODO

Files par taille de graph
Ameliorer tree_width_rec
=> Memoization
Regarder pour dernier algo voir et puis on focus sur les reuultats


          Tree_width
tree_width    |  tree_width_rec (Memoization)
            Small 
        Moyenne temps
0.441927 ms   | 1.867978 ms
         Global temps
91.928201 ms  | 386.671558 ms

            Seven         
        Moyenne temps
8.761376 ms   | 1.952684 ms
        Global temps
9.135605 s    | 2.038602 s

            Middle         
        Moyenne temps
179.587503 ms   | 2.636544 ms
        Global temps
40 min 4.676 674 494s    | 35.303325 s


          Tree_width
tree_width    |  tree_width_rec (Memoization + MMD)
            Small 
        Moyenne temps
0.441927 ms   | 0.479100 ms
         Global temps
91.928201 ms  | 99.173880 ms

            Seven         
        Moyenne temps
8.761376 ms   | 0.896933 ms
        Global temps
9.135605 s    | 936.398691 ms

            Middle         
        Moyenne temps
179.587503 ms   | 1.776539 ms
        Global temps
40 min 4s       | 23.787864 s


ANALYSE TAILLE PAR TAILLE



tree_width    |  tree_width_rec (Memoization + MMD)

              Two
        Moyenne temps
0.014 799 ms  | 0.021 214 ms
        Global temps
0.029 599 ms  | 0.042 428 ms

            Three         
        Moyenne temps
0.014 293 ms  | 0.023 462 ms
        Global temps
0.057 172 ms    | 0.093 849 ms


            Four         
        Moyenne temps
0.016 560 ms   | 0.028 785 ms
        Global temps
0.182 166 ms    | 0.316635 ms

            Five        
        Moyenne temps
0.069 365 ms  | 0. 099 680 ms
        Global temps
2.358 443 ms   | 3. 389 151 ms

            Six         
        Moyenne temps
0.896 419 ms   | 0.590 637 ms
        Global temps
139. 841 403 ms    | 92. 139 523 ms
            Seven         
        Moyenne temps
8.761376 ms   | 0.896933 ms
        Global temps
9.135605 s    | 936.398691 ms

            Eight         
        Moyenne temps
8.761376 ms   | 1. 854 979 ms
        Global temps
9.135605 s    | 22. 901 575 s

            Nine         
        Moyenne temps
8.761376 ms   | 27.570 514 ms
        Global temps
9.135605 s    | 2h 06 min 12 s 738 127 317 

              Ten
        Moyenne temps
8.761376 ms   | 0.896933 ms
        Global temps
9.135605 s    | 936.398691 ms



TREE WIDHT REC AMELIORER 

Probleme dans algo ligne 7 dans le papier ca a pas de sens
=> normalement and et pas or devrait solve 


======================================
Jour 2
======================================

Tree Width Rec Amelioré

Implémentation + Temps

Technically O(2^n) => mieux que O(4^n)


fill-in graph => G+[W] 

G(V,E) > G'(W,F) > F = paths de v a w qui use des arretes de V-W


Tester demain sur plus gros algos


OK Algo fait

TO FIX:
Certaines valeurs sont incorrectes mais peu nombreuse juste elles commencent a pop dans les 7 et 8
(exemples dans main python)

Theorie MMD il y avait des blems avant sans doute mtn faut fix et verif

Anyway algo semble plus rapide par defaut
Different Middle 

Correct       Current
" F?AZO,1" != "F?AZO,2"
" G??AXg,1" != "G??AXg,2"
" G???~G,1" != "G???~G,2"
" G??MPg,1" != "G??MPg,2"
" G?CBKW,1" != "G?CBKW,2"
" G??KzW,2" != "G??KzW,3"
" G?CHM_,1" != "G?CHM_,2"
" G?@HcK,1" != "G?@HcK,2"
" G??}Ps,2" != "G??}Ps,3"
" G??}O{,2" != "G??}O{,3"
" G?AZVo,2" != "G?AZVo,3"
" G?@krs,2" != "G?@krs,3"
" G?BHp{,2" != "G?BHp{,3"
" G?Aip{,2" != "G?Aip{,3"
" G?BHvs,2" != "G?BHvs,3"
" G?AZR{,2" != "G?AZR{,3"
" G?AZV{,2" != "G?AZV{,3"
" G?W[jK,2" != "G?W[jK,3"
" G?GX}W,2" != "G?GX}W,3"
" G?GZ[w,2" != "G?GZ[w,3"
" G?oXnK,2" != "G?oXnK,3"
" G?K]NK,2" != "G?K]NK,3"
" G?C}R[,2" != "G?C}R[,3"
" G?EZR[,2" != "G?EZR[,3"
" G?C}V[,2" != "G?C}V[,3"
" G?r@pg,2" != "G?r@pg,3"
" G?KuUK,2" != "G?KuUK,3"
" G?dcjS,2" != "G?dcjS,3"
" G?N@m[,2" != "G?N@m[,3"
" G?rHpk,2" != "G?rHpk,3"
" G?dcz[,2" != "G?dcz[,3"
" G?qipk,2" != "G?qipk,3"
" G?hSz[,2" != "G?hSz[,3"


Toujours 1 de difference alors probablement pas non plus inhumain a solve
Probleme vient de Tree_width_Rec
