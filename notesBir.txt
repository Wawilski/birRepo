NetworkX

Invariant de graphe
_________________________________________

Moyenne et Variance des degrés de sommets de graphe

1- calculer Moyenne et Variance des noeuds d'un graphe donné (done)
2- faire des tests 
  créer des graphes randoms et si isomorphes regarder si même moyenne et même variance

Sachant que c'est bien un invariant:
  invariant = quantité qui est la meme pour tout graphe isomorphe  

  isomorphe => on peut associer ts les sommets d'un graphe G vers un graphe H et garde les arêtes


  sachant ça cela signifie que pour un sommet a de G, le sommet associé f(a) dans H possèdent le même nombre d'arrete et donc le meme degré
  et ce pour toutes les arretes. Si toutes les aretes on le meme degré entre 2 graphes alors la moyenne ne change pas car le meme nombre de noeud et les memes degrés
  comme la moyenne change pas et le degré change pas on est good


  Moyenne plus fort encore, si 2 graphes ont le meme nombre d'arete alors la moyenne des degrés est égale
  Logique en soit car une arete = 2 degrés distribués parmis les nodes et ce peut importe les nodes en questions
  et la moyenne additionne tous les degrés des noeuds donc sil y a une aretes qui change d'un noeud a un autre on a quand meme la meme moyenne des degrés comme lentrant dans lancien nodes
  juste se déplace

  Variance par contre que si isomorphes parce que les degrés respectifs des noeuds comptent


PRENDRE GRAPHES DU MAIL AVEC SIGNATURES CANONIQUES
CALCULER VALEUR DE VARIANCE POUR CHACUN
PRINT SINGATURE CANONIQUE ET VARIANCE

Bcp de valeurs: 12293434 values
Variance !=> iso
iso => Variance
_________________________________________

Circonference d'un graphe girth = plus court cycle
Deja implémenté mais implemente le

PLUS COURT CYCLE:

parcours en partant de chaque node on prend le plus court

BFS et dès qu'on tombe sur le node on prend la value

=================================================
Jour 2: treewidth
================================================
Plus petite decomposition


---pas bonne méthode heuristique---
Prend le gros TAS avec tous les nodes
au fur et a mesure on prend celui qui à le plus petit degré et on regarde a qui il est connecté dans le grand ensemble si cest possible on le retire et on ajoute un
node avec tous ses voisins
On continue dans que cest possible puis on passe sur un des noeuds créés et à la chaine 


--Naif--
tu prends tous les sous ensembles et tu composes pour voir si ca marche
Remarque de non tree

SI 2 eleement d'un noeud appartiennent a 2 noeud differents et 1 elemennt commun entre les 2 => merge
Ex:
  AB BC AC => ABC

Si double paire A B B A, A C C A Merge à 4

  BC CE BD DE => BCDE

=> premier tri 
Pour toutes les aretes checker si triangles dans ce cas il y a d'office un noeud qui contient les 3
Probablement plus long que de try



Naive method mais pas trop

Tous les sous ensembles possibles
commence par Sous ensemlbes plus petits (aretes)

On part d'une arete et on la link avec une possible 
si pas possible de link avec arete voisine merge les 2

si en ajoutant voisin on tombe sur un cycle
on prend ceux qui ont un commun on les mergent et le chiant on le met au milieu en ajoutant les commun des 2 merges
Marche pas

Naive method ++
On prend les ensembles d'arretes avec 2 item par node
puis 3 puis 4 ... 
- dès qu'on trouve un cycle on switch de possibilité et au bout d'un moment on atteindra bien un truc
- dès qu'on trouve une solution on est bon
sachant que peut pas dépasser n-1 item par noeud et peut pas etre en dessous de n-1 noeuds(nombre d'arrete)
        


=================================================
Jour 3: TreeWidth: le retour
=================================================


-- Ca ne lest pas --
Analyse de cliques voir si cest plus simple ou pas

TreeWidth = taille de la plus grande clique dans le chordal graph qui contient G avec le plus petit nombre de clique

Graph cordal: graphe avec pour chaque cycle de 4 ou plus à au moins une corde qui connecte 2 node du circuit


MEthod naive mais pas trop
Creation de tous les noeuds necessaire pour un certains K 
tentative de connection en ajoutant des noeuds, si marche pas switch et faire toutes les possibilités pour un k donné

Si 2 et cycle on switch instant

Pour petits seems fine pour 10 complex



OK final algo from Melo


Logique algo

Algorithme naif, on va faire toutes les possibilités mais de maniere intelligente

Soit:
-G un graph dont on veut connaitre la treewidth, 
ses nodes sont numérotées de 0 à n, n le nombre de node 

o_perm correspond a la liste des nodes de G, numérotés selon un certain ordre,
cette variable permettra de stocker les permutations des nodes

L'algo suit la logique suivante:
  
  Nous allons créer un nouveau graphe, C, copie de G, sauf que nous allons renommés les sommets selon o_perm
  Cela permettra par la suite d'explorer les aretes des noeuds dans un ordre different à chaque itération
  permettant d'explorer toutes les possibilités de treeDecomposition
  
  Après avoir créé ce graphe C, nous allons calculer le degré Maximum dans C, nMaxDeg
  Ce degré nous permettra de connaitre la width de l'arbre

  Pour ce faire nous allons explorer les noeuds de C dans l'ordre numérique
  Pour chaque noeud i nous allons stocker le degré courant dans nDeg et allons garder en mémoire
  first, le premier noeud avec qui i à une arete en commun
  Nous allons donc a partir de i explorer les noeuds dont le numéro est strictement supérieur à i
  et verifier sil y a une arete, si cest le cas nous incrémentons nDeg et verifions si j est le premier
  noeud avec qui il y a liaison, si cest le cas nous le stockons dans first sinon nous ajoutons une arete
  dans C reliant first et j


  Cela permetra de gérer les cycles problematiques dans le graphe s'il y en a, en ajoutant cette arrete
  on ajoute un au degré de j et de first et donc potentiellement la cardinalité des nodes via nDeg et nMaxDeg
=====
TODO
=====
repo Git 

Continuer ce tree stuff et améliorer efficacité tout ça tout ça

suite
Comparaison defficacité RUST

invariants en plus
  proximity: Minimum de la distance moyenne des sommets du graphe
  remoteness: Maximum de la distance moyenne des sommets du graphe
  calculer? tu pars d'un sommet tu fais le plus cours chemin vers tous les sommets et tu stock 
  en gros BFS et tu gardes les distances à chaque fois tu peux opti en gardant la distance vers les noeuds que t'as deja visit pour les prochains mais pas worth parce que tu devras
  quand meme calculer


================================
Jour 4
===============================

repo git done
Proximity & remoteness implementés reste que le g6 file mais apres

a faire:
tenter de clean tout ce que deja fait
files g6 full (ff)
tenter de voir implementation en rust probablement plus fast uk


Ameliorer TreeWidth
  - Trouver borne inferieure et si atteinte alors on stop ? Done et marche bien permet pour certains graphes particuliers de le faire en une itération (exemple dans main avec le grapges à 7 sommets avec que des triangles) ou alors les fully connected graph
  - Break si on a un degré superieur au minimum (logique) done et is ok ca reduit deja bien (si on considère que le 1er noeud a un degré superieur on gagne n**2 itération cest pas mal)
  - Ignorer des permutations? un monde ou c'est possible

lower bound sur small
Economie de 4 secondes 
lower bound sur middle (que ceux de taille 7)
avec lower: 32 sec
sans lower : 2min
divise le temps par 4 de ce que vu



Reste à faire:
Rust
Encore ptetre améliorer treewidth avec upperbound
file g6 remoteness & proximity


============================
Jour 5
============================


Implémentation des graphs, girth et tree_width en rust

######################################################
                  Semaine 2
######################################################

===========================
Jour 1
===========================

Fixing Proximity and Remoteness + faire files (done)

Rust: Implémentation Lower Bound TreeWidth, Proximity and Remoteness

Temps exe

          Tree_width
Rust          |   Python 
            Small 
        Moyenne temps
0.441927 ms   |   1.472783 ms
        Global temps
91.928201 ms  |   313.796831 ms

            Seven         
        Moyenne temps
8.761376 ms   |   30.830548 ms
        Global temps
9.135605 s    |   32.038462 s



Implémenter Prox et Remoteness


     Proximity/Remoteness
    (Probablement Probleme)
Rust          |   Python 
            Small 
        Moyenne temps
0.021859 ms   |   0.038064 ms
        Global temps
4.524906 ms  |    7.879252 ms

            Seven         
        Moyenne temps
0.034531 ms   |   0.056277 ms
        Global temps
36.050836 ms    |   58.753757 ms
     

            Girth
Rust          |   Python 
            Small 
        Moyenne temps
0.020546 ms   |   0.029426 ms
        Global temps
4.253045 ms  |    6.091343 ms

            Seven         
        Moyenne temps
0.031026 ms   |   0.044273 ms
        Global temps
32.391704 ms    |  46.221144 ms
            
          Variance
Rust          |   Python 
            Small 
        Moyenne temps
0.009553 ms   |   0.016899 ms
        Global temps
1.977510 ms  |    3.498293 ms

            Seven         
        Moyenne temps
0.010675 ms   |   0.021364 ms
        Global temps
11.145605 ms    |  22.304676 ms


=======================================
  Jour 2
======================================

Recap:
  Invariants en python et en rust
    Variance
    Girth (circonférence)
    Proximity
    Remoteness
    Tree Width
  Comparaison des temps d'exe des algos
    Rust toujours plus rapide meme si ptetre améliorable

#TODO
  CLEAN CODE ET AMELIORER STUFF
  SIGNER CONTRAT
  
Rust Cleaned au max du possible

AMELIORER TREE WIDTH


Ok upperbound

tw(G) < |S| + max(tw(G_i))


=> Retire vertices puis prends la tailles des sous graph de G - S - 1 pour leur tw
ca créra un upperbound qui sera impossible d'aller au dessus

=====================================
Jour 3
=====================================

ALGORITHMES A EXPLO

Arnborg et al. O(n^k+2) Pour dire si tree width de taille au plus k <= en vrai à l'ai sympa O(2^n) pour un k donné

Farni et al. && Villanger Use Separator et cliques (vu hier takapté) O(1.9^n) pour Farni et un peu moins pour VIllanger <= Peut etre sympa mais disent dur à implementer

Paper Found <= Linear Ordering Vertices tq specific measure of cost as small as possible O(2^n) jsp ce que ca signifie mais ca à l'air marrant



Propal intéressantes 

soit G = (V,E), k entier

1. tw(G) =k
<=>
2. G a triangulation H = (V,F) avec max taille de clique = k +1
<=>
3. Same que 2 mais H triangulation minimale


Tenter a implémenté 
Recursive Algo O(4^n) mieux que l'autre en O(n!)
  Calculer 2 choses:
    Q(L,v) = |{w from V - S - {v}| path between v and w dans G[S U {v,w}]}|
    Subsets de S, S' avec |S'| = |S|/2

Ok implémenté mais à debuguer

Demain 
  Debuguer parce que stack overflow
  Check reste des algos du papier
  Si le temps check Arnborg

=====================================
Jour 4
====================================
Recursif done 

          Tree_width
tree_width    |  tree_width_rec (non opti)
            Small 
        Moyenne temps
0.441927 ms   | 1.547482 ms
         Global temps
91.928201 ms  | 320.328936 ms


            Seven         
        Moyenne temps
8.761376 ms   | 8.652135 ms
        Global temps
9.135605 s    | 9.032829 s

2030029038
1²944472

meme si pas optimisé il s'améliore quand on monte en taille et rattrape le tree_width par defaut

######################################################
                  Semaine 3
######################################################

===========================
Jour 1
===========================

TODO

Files par taille de graph
Ameliorer tree_width_rec
=> Memoization
Regarder pour dernier algo voir et puis on focus sur les reuultats


          Tree_width
tree_width    |  tree_width_rec (Memoization)
            Small 
        Moyenne temps
0.441927 ms   | 1.867978 ms
         Global temps
91.928201 ms  | 386.671558 ms

            Seven         
        Moyenne temps
8.761376 ms   | 1.952684 ms
        Global temps
9.135605 s    | 2.038602 s

            Middle         
        Moyenne temps
179.587503 ms   | 2.636544 ms
        Global temps
40 min 4.676 674 494s    | 35.303325 s


          Tree_width
tree_width    |  tree_width_rec (Memoization + MMD)
            Small 
        Moyenne temps
0.441927 ms   | 0.479100 ms
         Global temps
91.928201 ms  | 99.173880 ms

            Seven         
        Moyenne temps
8.761376 ms   | 0.896933 ms
        Global temps
9.135605 s    | 936.398691 ms

            Middle         
        Moyenne temps
179.587503 ms   | 1.776539 ms
        Global temps
40 min 4s       | 23.787864 s


ANALYSE TAILLE PAR TAILLE



tree_width    |  tree_width_rec (Memoization + MMD)

              Two
        Moyenne temps
0.014 799 ms  | 0.021 214 ms
        Global temps
0.029 599 ms  | 0.042 428 ms

            Three         
        Moyenne temps
0.014 293 ms  | 0.023 462 ms
        Global temps
0.057 172 ms    | 0.093 849 ms


            Four         
        Moyenne temps
0.016 560 ms   | 0.028 785 ms
        Global temps
0.182 166 ms    | 0.316635 ms

            Five        
        Moyenne temps
0.069 365 ms  | 0. 099 680 ms
        Global temps
2.358 443 ms   | 3. 389 151 ms

            Six         
        Moyenne temps
0.896 419 ms   | 0.590 637 ms
        Global temps
139. 841 403 ms    | 92. 139 523 ms
            Seven         
        Moyenne temps
8.761376 ms   | 0.896933 ms
        Global temps
9.135605 s    | 936.398691 ms

            Eight         
        Moyenne temps
8.761376 ms   | 1. 854 979 ms
        Global temps
9.135605 s    | 22. 901 575 s

            Nine         
        Moyenne temps
8.761376 ms   | 27.570 514 ms
        Global temps
9.135605 s    | 2h 06 min 12 s 738 127 317 

              Ten
        Moyenne temps
8.761376 ms   | 0.896933 ms
        Global temps
9.135605 s    | 936.398691 ms



TREE WIDHT REC AMELIORER 

Probleme dans algo ligne 7 dans le papier ca a pas de sens
=> normalement and et pas or devrait solve 


======================================
Jour 2
======================================

Tree Width Rec Amelioré

Implémentation + Temps

Technically O(2^n) => mieux que O(4^n)


fill-in graph => G+[W] 

G(V,E) > G'(W,F) > F = paths de v a w qui use des arretes de V-W


Tester demain sur plus gros algos


OK Algo fait

TO FIX:
Certaines valeurs sont incorrectes mais peu nombreuse juste elles commencent a pop dans les 7 et 8
(exemples dans main python)

Theorie MMD il y avait des blems avant sans doute mtn faut fix et verif

Anyway algo semble plus rapide par defaut
Different Middle 

Correct       Current
" F?AZO,1" != "F?AZO,2"
" G??AXg,1" != "G??AXg,2"
" G???~G,1" != "G???~G,2"
" G??MPg,1" != "G??MPg,2"
" G?CBKW,1" != "G?CBKW,2"
" G??KzW,2" != "G??KzW,3"
" G?CHM_,1" != "G?CHM_,2"
" G?@HcK,1" != "G?@HcK,2"
" G??}Ps,2" != "G??}Ps,3"
" G??}O{,2" != "G??}O{,3"
" G?AZVo,2" != "G?AZVo,3"
" G?@krs,2" != "G?@krs,3"
" G?BHp{,2" != "G?BHp{,3"
" G?Aip{,2" != "G?Aip{,3"
" G?BHvs,2" != "G?BHvs,3"
" G?AZR{,2" != "G?AZR{,3"
" G?AZV{,2" != "G?AZV{,3"
" G?W[jK,2" != "G?W[jK,3"
" G?GX}W,2" != "G?GX}W,3"
" G?GZ[w,2" != "G?GZ[w,3"
" G?oXnK,2" != "G?oXnK,3"
" G?K]NK,2" != "G?K]NK,3"
" G?C}R[,2" != "G?C}R[,3"
" G?EZR[,2" != "G?EZR[,3"
" G?C}V[,2" != "G?C}V[,3"
" G?r@pg,2" != "G?r@pg,3"
" G?KuUK,2" != "G?KuUK,3"
" G?dcjS,2" != "G?dcjS,3"
" G?N@m[,2" != "G?N@m[,3"
" G?rHpk,2" != "G?rHpk,3"
" G?dcz[,2" != "G?dcz[,3"
" G?qipk,2" != "G?qipk,3"
" G?hSz[,2" != "G?hSz[,3"


Toujours 1 de difference alors probablement pas non plus inhumain a solve
Probleme vient de Tree_width_Rec


=====================================
Jour 3
=====================================

Bug solve tree width REC chercher pourquoi "F?AZO,1" != "F?AZO,2" 
theorie outpath est pas correct (il marchait des le debut kinda sus)

Memoization marche pas pour ca que ca posait probleme 
=> Trouver nouveau moyen de memoizer => Pas moyen tjrs des resultats differents


tree_width    |  tree_width_rec (MMD)

              Two
        Moyenne temps
0.014 799 ms  | 0.028 552 ms
        Global temps
0.029 599 ms  | 0.057 105 ms


            Three         
        Moyenne temps
0.014 293 ms  | 0.026 684 ms
        Global temps
0.057 172 ms  | 0.106 736 ms


            Four         
        Moyenne temps
0.016 560 ms   | 0.029 198 ms
        Global temps
0.182 166 ms    | 0.321 188 ms

            Five        
        Moyenne temps
0.069 365 ms  | 0. 044 219 ms
        Global temps
2.358 443 ms   | 1.437 036 ms

            Six         
        Moyenne temps
0.896 419 ms   | 0.176 837 ms
        Global temps
139. 841 403 ms    | 27. 586 716 ms

            Seven         
        Moyenne temps
8.761376 ms   | 1.056 264 ms
        Global temps
9.135605 s    | 1.102 740 s


            Eight         
        Moyenne temps
184.561 831 ms   | 7. 236 091 ms
        Global temps

2278. 600 369 402 s    | 89.336 779 s



vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv

            Nine         
        Moyenne temps
8.761376 ms   | 27.570 514 ms
        Global temps
9.135605 s    | 2h 06 min 12 s 738 127 317 

              Ten
        Moyenne temps
8.761376 ms   | 0.896933 ms
        Global temps
9.135605 s    | 936.398691 ms





tree_width_up| tree_width_down |  tree_width_rec (MMD)

              Two
        Moyenne temps
0.030 603 ms  |0.035 224 ms  | 0.028 552 ms
        Global temps
0.061 207 ms  |0.070 448 ms  | 0.057 105 ms

            Three         
        Moyenne temps
0.049 111 ms  |0.049 345 ms  | 0.026 684 ms
        Global temps
0.196 444ms  |0.197 383 ms  | 0.106 736 ms

            Four         
        Moyenne temps
0.087 380 ms  |0.077 923 ms   | 0.029 198 ms
        Global temps
0.961 182 ms  |0.857 157 ms    | 0.321 188 ms

            Five        
        Moyenne temps
0.184 474 ms  |0.161 804 ms  | 0. 044 219 ms
        Global temps
6.272 146 ms  |5.501 354 ms   | 1.437 036 ms


            Six         
        Moyenne temps
0.387 953 ms  |0.306 241 ms   | 0.176 837 ms
        Global temps
60. 520 694 ms  |47.773 622 ms    | 27. 586 716 ms

            Seven         
        Moyenne temps
0.759 058 ms  |0.566 938 ms   | 1.056 264 ms
        Global temps
792.456 825 ms  |591.884 116 ms    | 1.102 740 s

            Eight         
        Moyenne temps
1.623 107 ms  |1.171 366 ms   | 7. 236 091 ms
        Global temps
20.038 888 962 s  |14. 461 686 s    | 89.336 779 s

          Small_Nine 
(5000 plus ptt + 5000 pls gds)         
        Moyenne temps
3.135 571 ms  |1.818 453 ms  | 17.193 570 ms

       Global temps

31.365 119 s  |18.186 353 s  | 2min51s.987 288 019s

            Nine         
        Moyenne temps
3.513 744 ms       |2.364 993 ms           | 27.570 514 ms  
        Global temps
16m 5s.113 285 760 |10 min 49s 587 952 796  | 2h 06 min 12 s 738 127 317 

            Small Ten        
        Moyenne temps

9.822 632 ms  |6.660 719 ms   | _____________-
        Global temps
8min11s131 631 192 |5 min 33s 035 980 842 | ___________


ESTIMATION DE TEN ~10h Ptetre le faire un jour

On a donc ordre de meilleur au pire

Improved_Rec_Down > Improvec_Rec_Up > Rec_basique > Naive  


TWDP ALGORITHM
ERREUR DANS PSEUDO CODE ARTICLE r' = MAX() pas MIN

==========================================
Jour 4
=========================================

TODO fix TWDP + Resultats 
CLEAN CODES 


tree_width DP| tree_width_down 

              Two
        Moyenne temps
0.024 396 ms  |0.035 224 ms  
        Global temps
0.048 793 ms  |0.070 448 ms 

            Three         
        Moyenne temps
0.031 099 ms  |0.049 345 ms
        Global temps
0.124 398 ms  |0.197 383 ms

            Four         
        Moyenne temps
0.075 171 ms  |0.077 923 ms 
        Global temps
0.826 888 ms  |0.857 157 ms

            Five        
        Moyenne temps
0.252 817 ms  |0.161 804 ms 
        Global temps
8.595 779 ms  |5.501 354 ms

            Six         
        Moyenne temps
0.766 993 ms  |0.306 241 ms   
        Global temps
119.650 969 ms  |47.773 622 ms

            Seven         
        Moyenne temps
2.462 354 ms  |0.566 938 ms  
        Global temps
2.570 698 153 s  |591.884 116 ms

            Eight         
        Moyenne temps
7. 865 497 ms  |1.171 366 ms   
        Global temps
1min37 s 107 437 155 |14. 461 686 s

   

          Small_Nine 
(5000 plus ptt + 5000 pls gds)         
        Moyenne temps
26.072 726 ms  |1.818 453 ms  
       Global temps
4min 20s 805 485 684  |18.186 353 s 

            Nine         
        Moyenne temps
__________ ms       |2.408 592 ms      
        Global temps |
__________ | 10min 49s 563 398 196 

Moins bon probablement à cause des comparaisons de liste 

graph2to9 tree_width
Total = 11min 10s 054 240 803
Moyenne = 2. 324 430ms



Comparaison Rust Python le retour

Variance moyenne temps:
Rust      Python

two:  22864   two:
three:16802   three:
four: 14076   four:
Five: 12567   Five:
six:  13823   six :
Seven:14732   Seven:
Eight:16267   Eight:
Nine: 17870   Nine:
Ten:  19809   Ten:

Proximity/Remoteness moyenne temps:
Rust      Python

two:  20958   two:
three:16109   three:
four: 15483   four:
Five: 21612   Five:
six:  25196   six :
Seven:32319   Seven:
Eight:42360   Eight:
Nine: 53905   Nine:
Ten:  70827   Ten:

Girth
Rust      Python

two:  19889   two:
three:15396   three:
four: 15651   four:
Five: 17933   Five:
six:  23975   six :
Seven:30412   Seven:
Eight:39477   Eight:
Nine: 49350   Nine:
Ten:  62474   Ten:



================================
Jour 5
================================

TODO
Expliquer algo
finir comparaisons 
verif veracité une dernière fois


WK TODO 
Run 10 sized graph
Finir explications algos

Ten 1 tree_width down 
Global
33634 600 931 259 ~ 9h

Moyenne
5.603 353 ms

35748 244 598 254
5955475


###############################
        SEMAINE 4
###############################

===============================
Jour 1
===============================


TODO
Finir explications algos
Faire tous les outputs
--
Tous les outputs Done
Explications Algos à pofiner 

Graphiques DOne

Commencer Rapport --> Canva fait

